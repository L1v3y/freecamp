#include <stdio.h>
#include <pthread.h>

#define MAX_READERS 100
#define MAX_WRITERS 100

int num_readers, num_writers;
pthread_mutex_t mutex;
pthread_cond_t cond_read, cond_write;
int reader_count = 0, writer_count = 0, writer_waiting = 0;

void *reader(void *arg) {
    int id = *(int *) arg;
    while (1) {
        // acquire the mutex
        pthread_mutex_lock(&mutex);
        
        // wait if there is a writer waiting or currently writing
        while (writer_waiting || writer_count > 0) {
            pthread_cond_wait(&cond_read, &mutex);
        }
        
        // increment the number of readers and signal any waiting writers
        reader_count++;
        pthread_cond_signal(&cond_read);
        
        // release the mutex
        pthread_mutex_unlock(&mutex);
        
        // read the shared resource
        printf("Reader %d reading...\n", id);
        
        // acquire the mutex
        pthread_mutex_lock(&mutex);
        
        // decrement the number of readers and signal any waiting writers
        reader_count--;
        if (reader_count == 0) {
            pthread_cond_signal(&cond_write);
        }
        
        // release the mutex
        pthread_mutex_unlock(&mutex);
        
        // sleep for a random amount of time before reading again
        usleep(rand() % 1000000);
    }
    return NULL;
}

void *writer(void *arg) {
    int id = *(int *) arg;
    while (1) {
        // acquire the mutex
        pthread_mutex_lock(&mutex);
        
        // wait if there are any readers or writers currently writing
        writer_waiting++;
        while (reader_count > 0 || writer_count > 0) {
            pthread_cond_wait(&cond_write, &mutex);
        }
        writer_waiting--;
        writer_count++;
        
        // release the mutex
        pthread_mutex_unlock(&mutex);
        
        // write to the shared resource
        printf("Writer %d writing...\n", id);
        
        // acquire the mutex
        pthread_mutex_lock(&mutex);
        
        // decrement the number of writers and signal any waiting readers or writers
        writer_count--;
        if (writer_waiting > 0) {
            pthread_cond_signal(&cond_write);
        } else {
            pthread_cond_broadcast(&cond_read);
        }
        
        // release the mutex
        pthread_mutex_unlock(&mutex);
        
        // sleep for a random amount of time before writing again
        usleep(rand() % 1000000);
    }
    return NULL;
}

int main() {
    int i;
    pthread_t readers[MAX_READERS], writers[MAX_WRITERS];
    int reader_ids[MAX_READERS], writer_ids[MAX_WRITERS];
    
    // initialize the mutex and condition variables
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond_read, NULL);
    pthread_cond_init(&cond_write, NULL);
    
    // get user input for the number of readers and writers
    printf("Enter the number of readers (up to %d): ", MAX_READERS);
    scanf("%d", &num_readers);
    printf("Enter the number of writers (up to %d): ", MAX_WRITERS);
    scanf("%d", &num_writers);
    
    // create the reader threads
    for (i = 0; i < num_readers; i++) {
        reader_ids[i] = i + 1;
        pthread_create(&readers[i], NULL, reader, &reader_ids[i]);
}

// create the writer threads
for (i = 0; i < num_writers; i++) {
    writer_ids[i] = i + 1;
    pthread_create(&writers[i], NULL, writer, &writer_ids[i]);
}

// wait for the threads to exit
for (i = 0; i < num_readers; i++) {
    pthread_join(readers[i], NULL);
}
for (i = 0; i < num_writers; i++) {
    pthread_join(writers[i], NULL);
}

// destroy the mutex and condition variables
pthread_mutex_destroy(&mutex);
pthread_cond_destroy(&cond_read);
pthread_cond_destroy(&cond_write);

return 0;

